<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"/>
<title>Pelan Sampler v1.4.0</title>

<!-- PWA Meta Tags -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Pelan Sampler">
<meta name="mobile-web-app-capable" content="yes">
<meta name="theme-color" content="#1f1f1f">

<style>
  * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
  html,body { 
    margin:0; 
    padding:10px; 
    background:#1f1f1f; 
    color:#fff; 
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif; 
    user-select:none; 
    -webkit-user-select:none; 
    touch-action: manipulation;
    padding-top: max(10px, env(safe-area-inset-top));
    padding-bottom: max(10px, env(safe-area-inset-bottom));
    padding-left: max(10px, env(safe-area-inset-left));
    padding-right: max(10px, env(safe-area-inset-right));
    overscroll-behavior: none;
    -webkit-overflow-scrolling: touch;
    height: 100vh;
    height: 100dvh;
  }
  input, select, textarea, button { font-size: 16px; }
  #versionLabel { text-align:center; margin-bottom:10px; font-size:13px; color:#aaa; font-weight:600; }

  /* Sampler */
  .pad-grid { display:grid; grid-template-columns: repeat(3,1fr); gap:12px; margin-bottom:14px; }
  .pad {
    aspect-ratio:1; min-height:100px; background:#4d4d4d; border:2px solid #3b3b3b; border-radius:12px;
    display:flex; flex-direction:column; align-items:center; justify-content:center; cursor:pointer; 
    transition: transform .06s ease; position: relative;
    -webkit-touch-callout: none; -webkit-user-select: none;
  }
  .pad:active { transform: scale(0.98); }
  .pad.active { background:#e67e22; }
  .pad.has-sample { background:#2e9b60; }
  .pad.selected { border-color:#f1c40f; }
  .pad.muted1::before { content:'M1'; position:absolute; top:4px; left:6px; font-size:9px; font-weight:bold; color:#ff6b6b; background:#333; border-radius:50%; width:18px; height:18px; display:flex; align-items:center; justify-content:center; }
  .pad.muted2::before { content:'M2'; position:absolute; top:4px; left:6px; font-size:9px; font-weight:bold; color:#00d1ff; background:#333; border-radius:50%; width:18px; height:18px; display:flex; align-items:center; justify-content:center; }
  .pad.muted3::before { content:'M3'; position:absolute; top:4px; left:28px; font-size:9px; font-weight:bold; color:#f1c40f; background:#333; border-radius:50%; width:18px; height:18px; display:flex; align-items:center; justify-content:center; }
  .pad-number { font-weight:800; font-size:18px; }
  .pad-name { font-size:12px; margin-top:4px; text-overflow:ellipsis; overflow:hidden; white-space:nowrap; max-width:90%; }

  button { 
    padding:10px 14px; border:none; border-radius:8px; font-weight:700; cursor:pointer; margin:4px; color:#fff; background:#444;
    -webkit-appearance: none; -webkit-touch-callout: none; font-size: 16px;
  }
  #recordBtn { background:#e74c3c; }
  #loadBtn { background:#27ae60; }
  .clear-btn { background:#c0392b; }
  #muteGroup1Btn { background:#9b59b6; }
  #muteGroup1Btn.active { background:#e74c3c; }
  #muteGroup2Btn { background:#3498db; }
  #muteGroup2Btn.active { background:#00d1ff; }
  #muteGroup3Btn { background:#f39c12; }
  #muteGroup3Btn.active { background:#f1c40f; color:#333; }
  #toggleSequencerBtn { background:#2980b9; }

  .controls { background:#2b2b2b; padding:10px; border-radius:10px; margin-top:8px; }
  .row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  .group { display:flex; align-items:center; gap:8px; flex:1 1 180px; }
  .group label { width:86px; font-size:13px; color:#ddd; }
  .group input[type=range] { 
    flex:1; -webkit-appearance: none; height: 6px; border-radius: 3px; background: #555; outline: none;
  }
  .group input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none; appearance: none; width: 20px; height: 20px; border-radius: 50%; background: #f1c40f; cursor: pointer;
  }
  .group span { width:48px; text-align:right; font-size:12px; opacity:.85; }

  #status { margin-top:8px; font-size:14px; opacity:.9; }

  .rec-indicator { position: fixed; top: 0; left: 0, right: 0; height: 4px; background: linear-gradient(90deg, #ff0000, #ff5252); box-shadow: 0 0 12px #ff0000; opacity: 0; pointer-events: none; transition: opacity .2s; z-index: 9999; }
  .rec-on .rec-indicator { opacity: 1; animation: recPulse 1s infinite; }
  @keyframes recPulse { 0%{ box-shadow: 0 0 6px #ff0000; } 50%{ box-shadow: 0 0 16px #ff0000; } 100%{ box-shadow: 0 0 6px #ff0000; } }

  @supports (-webkit-touch-callout: none) {
    .pad { -webkit-tap-highlight-color: rgba(0,0,0,0); }
    button { -webkit-tap-highlight-color: rgba(0,0,0,0); }
  }

  /* Sequencer */
  .hidden { display:none !important; }
  .sequencer { margin-top:12px; }
  .transport { 
    background:#2b2b2b; 
    padding:12px; 
    border-radius:10px; 
    margin-bottom:16px;
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
  }
  #playPauseBtn { background:#27ae60; }
  #playPauseBtn.playing { background:#f39c12; }
  #tapTempoBtn { background:#9b59b6; }
  #backBtn { background:#34495e; }

  .tempo-input {
    width: 72px;
    padding: 6px 8px;
    border: 1px solid #555;
    border-radius: 6px;
    background: #333;
    color: #fff;
    text-align: center;
  }
  .swing-slider {
    -webkit-appearance:none;
    height:6px; border-radius:3px; background:#555; outline:none; width: 160px;
  }
  .swing-slider::-webkit-slider-thumb {
    -webkit-appearance:none; width:20px; height:20px; border-radius:50%; background:#f1c40f; cursor:pointer;
  }

  .sequencer-grid {
    background:#2b2b2b; padding:12px; border-radius:10px; overflow-x:auto;
  }
  .grid-header, .track-row {
    display:grid; grid-template-columns: 80px repeat(8, 1fr); gap:4px; align-items:center;
  }
  .grid-header { margin-bottom:8px; }
  .beat-number { text-align:center; font-size:12px; color:#aaa; font-weight:600; }
  .track-label { font-size:12px; color:#ddd; text-align:center; font-weight:600; background:#3b3b3b; padding:8px 4px; border-radius:6px; min-height:40px; display:flex; align-items:center; justify-content:center; }
  .step-button { aspect-ratio:1; min-height:40px; background:#4d4d4d; border:2px solid #3b3b3b; border-radius:8px; cursor:pointer; transition: all .08s ease; display:flex; align-items:center; justify-content:center; position:relative; }
  .step-button.active { background:#2e9b60; border-color:#27ae60; }
  .step-button.current-beat { border-color:#f1c40f; box-shadow:0 0 8px rgba(241,196,15,.3); }
  .step-button.playing { background:#e67e22; border-color:#d35400; box-shadow:0 0 10px rgba(230,126,34,.4); }

  @media (max-width: 600px) {
    .grid-header, .track-row { grid-template-columns: 64px repeat(8, 1fr); }
    .track-label { font-size:11px; padding:6px 3px; }
    .step-button { min-height:36px; }
  }
</style>
</head>
<body>
  <div class="rec-indicator"></div>

  <div id="versionLabel">Pelan Sampler v1.4.0</div>

  <!-- Sampler View -->
  <div id="samplerView">
    <div class="pad-grid" id="padGrid"></div>

    <div>
      <button id="recordBtn">Record</button>
      <input type="file" id="fileInput" accept="audio/*" style="display:none;">
      <button id="loadBtn">Load</button>
      <button id="clearPad" class="clear-btn">Clear</button>
      <button id="muteGroup1Btn">Mute 1</button>
      <button id="muteGroup2Btn">Mute 2</button>
      <button id="muteGroup3Btn">Mute 3</button>
      <button id="toggleSequencerBtn">Sequencer</button>
    </div>

    <div class="controls">
      <div class="row">
        <div class="group">
          <label>Master Vol</label>
          <input type="range" id="masterVol" min="0" max="100" value="80">
          <span id="masterVolVal">80%</span>
        </div>
        <div class="group">
          <label>Pad Vol</label>
          <input type="range" id="padVol" min="0" max="100" value="80">
          <span id="padVolVal">80%</span>
        </div>
      </div>
      <div class="row">
        <div class="group">
          <label>Pitch</label>
          <input type="range" id="padPitch" min="0.5" max="2" step="0.1" value="1">
          <span id="padPitchVal">1.0x</span>
        </div>
        <div class="group">
          <label>Time Stretch</label>
          <input type="range" id="timeStretch" min="0.25" max="4" step="0.05" value="1">
          <span id="timeStretchVal">1.0x</span>
        </div>
      </div>
      <div class="row">
        <div class="group">
          <label>Start</label>
          <input type="range" id="padStart" min="0" max="100" value="0">
          <span id="padStartVal">0%</span>
        </div>
        <div class="group">
          <label>End</label>
          <input type="range" id="padEnd" min="0" max="100" value="100">
          <span id="padEndVal">100%</span>
        </div>
      </div>
      <div class="row">
        <div class="group">
          <label>Filter</label>
          <input type="range" id="filter" min="0" max="100" value="50">
          <span id="filterVal">OFF</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Sequencer View -->
  <div id="sequencerView" class="hidden">
    <div class="transport">
      <button id="playPauseBtn">Play</button>
      <button id="tapTempoBtn">Tap Tempo</button>

      <label>BPM:</label>
      <input type="number" id="tempoInput" class="tempo-input" min="60" max="200" value="120">

      <label>Swing:</label>
      <input type="range" id="swingSlider" class="swing-slider" min="50" max="100" value="50">
      <span id="swingValue">50%</span>

      <button id="backBtn">Back to Sampler</button>
    </div>

    <div class="sequencer-grid">
      <div class="grid-header">
        <div></div>
        <div class="beat-number">1</div>
        <div class="beat-number">2</div>
        <div class="beat-number">3</div>
        <div class="beat-number">4</div>
        <div class="beat-number">5</div>
        <div class="beat-number">6</div>
        <div class="beat-number">7</div>
        <div class="beat-number">8</div>
      </div>
      <div id="sequencerTracks"></div>
    </div>
  </div>

  <div id="status">Ready</div>

<script>
// iOS compatibility improvements
(function(){
  let last=0; 
  document.addEventListener('touchend',e=>{
    const now=Date.now(); 
    if(now-last<300){ e.preventDefault(); } 
    last=now;
  },{passive:false,capture:true});
  ['gesturestart','gesturechange','gestureend'].forEach(evt=>document.addEventListener(evt,e=>e.preventDefault()));
  document.addEventListener('touchmove', function(e) {
    if(e.target.closest('.controls') || e.target.closest('.transport')) return;
    e.preventDefault();
  }, {passive: false});
})();

// Service Worker registration for PWA (kept minimal)
if ('serviceWorker' in navigator) {
  window.addEventListener('load', function() {
    const swCode = `
    const CACHE_NAME = 'pelan-sampler-v1';
    self.addEventListener('install', event => {
      event.waitUntil(caches.open(CACHE_NAME).then(cache => cache.addAll(['/'])));
    });
    self.addEventListener('fetch', event => {
      event.respondWith(caches.match(event.request).then(response => response || fetch(event.request)));
    });
    `;
    const blob = new Blob([swCode], {type: 'application/javascript'});
    const swUrl = URL.createObjectURL(blob);
    navigator.serviceWorker.register(swUrl).catch(()=>{});
  });
}

class Sampler {
  constructor(){
    this.ctx = new (window.AudioContext||window.webkitAudioContext)({
      latencyHint:'interactive',
      sampleRate: 44100
    });

    this.masterIn = this.ctx.createGain();
    this.masterGain = this.ctx.createGain();
    this.masterIn.connect(this.masterGain);
    this.masterGain.connect(this.ctx.destination);
    this.masterGain.gain.value = 0.8;

    this.pads = {}; this.sel = null; this.count = 9;

    this.recorder=null; this.chunks=[]; this.isRecording=false;

    this.ui = {
      grid: document.getElementById('padGrid'),
      file: document.getElementById('fileInput'),
      load: document.getElementById('loadBtn'),
      clear: document.getElementById('clearPad'),
      rec: document.getElementById('recordBtn'),
      status: document.getElementById('status'),
      muteGroup1: document.getElementById('muteGroup1Btn'),
      muteGroup2: document.getElementById('muteGroup2Btn'),
      muteGroup3: document.getElementById('muteGroup3Btn'),
      mVol: document.getElementById('masterVol'), mVolVal: document.getElementById('masterVolVal'),
      vol: document.getElementById('padVol'), volVal: document.getElementById('padVolVal'),
      pitch: document.getElementById('padPitch'), pitchVal: document.getElementById('padPitchVal'),
      start: document.getElementById('padStart'), startVal: document.getElementById('padStartVal'),
      end: document.getElementById('padEnd'), endVal: document.getElementById('padEndVal'),
      timeStretch: document.getElementById('timeStretch'), timeStretchVal: document.getElementById('timeStretchVal'),
      filter: document.getElementById('filter'), filterVal: document.getElementById('filterVal'),
      samplerView: document.getElementById('samplerView'),
      sequencerView: document.getElementById('sequencerView'),
      toSeq: document.getElementById('toggleSequencerBtn'),
      backBtn: document.getElementById('backBtn'),
    };

    this.makePads();
    this.bind();
    this.unlockAudioContext();
    this.requestMicPermission();

    // Expose globally for sequencer
    window.sampler = this;
  }

  unlockAudioContext(){
    const unlock = () => {
      if(this.ctx.state === 'suspended') {
        this.ctx.resume().then(() => {
          document.removeEventListener('touchstart', unlock);
          document.removeEventListener('click', unlock);
        });
      }
    };
    document.addEventListener('touchstart', unlock);
    document.addEventListener('click', unlock);
  }

  async requestMicPermission(){
    try{
      const stream = await navigator.mediaDevices.getUserMedia({audio:true});
      stream.getTracks().forEach(t=>t.stop());
      this.say('Mic ready');
    }catch(err){
      console.warn('Mic permission not granted yet.');
    }
  }

  makePads(){
    for(let i=1;i<=this.count;i++){
      const d=document.createElement('div'); d.className='pad'; d.dataset.id=i;
      d.innerHTML=`<div class="pad-number">${i}</div><div class="pad-name">Pad ${i}</div>`;
      this.ui.grid.appendChild(d);
      this.pads[i]={ id:i, name:`Pad ${i}`, buf:null, vol:.85, pitch:1, start:0, end:1,
        timeStretch: 1, filter: 50,
        muteGroup1: false, muteGroup2: false, muteGroup3: false, currentSource: null,
        el:d };
    }
  }

  bind(){
    this.ui.grid.addEventListener('touchstart', (e)=>{
      e.preventDefault();
      const d=e.target.closest('.pad'); if(!d) return; 
      const id=+d.dataset.id; this.select(id); this.playNow(id);
    }, {passive: false});

    this.ui.grid.addEventListener('click', (e)=>{
      const d=e.target.closest('.pad'); if(!d) return; 
      const id=+d.dataset.id; this.select(id); this.playNow(id);
    });

    this.ui.load.addEventListener('click', ()=>this.ui.file.click());
    this.ui.file.addEventListener('change', e=>this.loadFile(e));
    this.ui.clear.addEventListener('click', ()=>this.clear());

    this.ui.muteGroup1.addEventListener('click', ()=>{
      if(!this.sel) return;
      const pad = this.pads[this.sel];
      pad.muteGroup1 = !pad.muteGroup1;
      pad.el.classList.toggle('muted1', pad.muteGroup1);
      this.ui.muteGroup1.classList.toggle('active', pad.muteGroup1);
      this.say(`Pad ${this.sel} mute group 1 ${pad.muteGroup1 ? 'ON' : 'OFF'}`);
    });

    this.ui.muteGroup2.addEventListener('click', ()=>{
      if(!this.sel) return;
      const pad = this.pads[this.sel];
      pad.muteGroup2 = !pad.muteGroup2;
      pad.el.classList.toggle('muted2', pad.muteGroup2);
      this.ui.muteGroup2.classList.toggle('active', pad.muteGroup2);
      this.say(`Pad ${this.sel} mute group 2 ${pad.muteGroup2 ? 'ON' : 'OFF'}`);
    });

    this.ui.muteGroup3.addEventListener('click', ()=>{
      if(!this.sel) return;
      const pad = this.pads[this.sel];
      pad.muteGroup3 = !pad.muteGroup3;
      pad.el.classList.toggle('muted3', pad.muteGroup3);
      this.ui.muteGroup3.classList.toggle('active', pad.muteGroup3);
      this.say(`Pad ${this.sel} mute group 3 ${pad.muteGroup3 ? 'ON' : 'OFF'}`);
    });

    this.ui.rec.addEventListener('click', ()=>this.toggleRec());

    this.ui.mVol.addEventListener('input', e=>{ const v=e.target.value; this.masterGain.gain.value=v/100; this.ui.mVolVal.textContent=v+'%'; });

    this.ui.vol.addEventListener('input', e=>{ if(!this.sel) return; const v=e.target.value/100; this.pads[this.sel].vol=v; this.ui.volVal.textContent=e.target.value+'%'; });
    this.ui.pitch.addEventListener('input', e=>{ if(!this.sel) return; const p=parseFloat(e.target.value); this.pads[this.sel].pitch=p; this.ui.pitchVal.textContent=p.toFixed(1)+'x'; });
    this.ui.start.addEventListener('input', e=>{ if(!this.sel) return; const s=e.target.value/100; this.pads[this.sel].start=s; this.ui.startVal.textContent=e.target.value+'%'; if(s>this.pads[this.sel].end){ this.pads[this.sel].end=s; this.ui.end.value=Math.round(s*100); this.ui.endVal.textContent=Math.round(s*100)+'%'; } });
    this.ui.end.addEventListener('input', e=>{ if(!this.sel) return; const en=e.target.value/100; this.pads[this.sel].end=en; this.ui.endVal.textContent=e.target.value+'%'; if(en<this.pads[this.sel].start){ this.pads[this.sel].start=en; this.ui.start.value=Math.round(en*100); this.ui.startVal.textContent=Math.round(en*100)+'%'; } });

    this.ui.timeStretch.addEventListener('input', e=>{ 
      if(!this.sel) return; 
      const ts=parseFloat(e.target.value); 
      this.pads[this.sel].timeStretch=ts; 
      this.ui.timeStretchVal.textContent=ts.toFixed(2)+'x'; 
    });
    
    this.ui.filter.addEventListener('input', e=>{ 
      if(!this.sel) return; 
      const f=parseInt(e.target.value); 
      this.pads[this.sel].filter=f; 
      if(f === 50) this.ui.filterVal.textContent='OFF';
      else if(f < 50) this.ui.filterVal.textContent='LP ' + Math.round((50-f)*2) + '%';
      else this.ui.filterVal.textContent='HP ' + Math.round((f-50)*2) + '%';
    });

    // View toggle
    this.ui.toSeq.addEventListener('click', ()=>{
      this.ui.samplerView.classList.add('hidden');
      this.ui.sequencerView.classList.remove('hidden');
    });
    this.ui.backBtn.addEventListener('click', ()=>{
      this.ui.samplerView.classList.remove('hidden');
      this.ui.sequencerView.classList.add('hidden');
    });
  }

  select(id){
    if(this.sel) this.pads[this.sel].el.classList.remove('selected');
    this.sel=id; this.pads[id].el.classList.add('selected');
    const p=this.pads[id];
    this.ui.vol.value=Math.round(p.vol*100); this.ui.volVal.textContent=Math.round(p.vol*100)+'%';
    this.ui.pitch.value=p.pitch; this.ui.pitchVal.textContent=p.pitch.toFixed(1)+'x';
    this.ui.start.value=Math.round(p.start*100); this.ui.startVal.textContent=Math.round(p.start*100)+'%';
    this.ui.end.value=Math.round(p.end*100); this.ui.endVal.textContent=Math.round(p.end*100)+'%';
    this.ui.timeStretch.value=p.timeStretch; this.ui.timeStretchVal.textContent=p.timeStretch.toFixed(2)+'x';
    this.ui.filter.value=p.filter; 
    if(p.filter === 50) this.ui.filterVal.textContent='OFF';
    else if(p.filter < 50) this.ui.filterVal.textContent='LP ' + Math.round((50-p.filter)*2) + '%';
    else this.ui.filterVal.textContent='HP ' + Math.round((p.filter-50)*2) + '%';

    this.ui.muteGroup1.classList.toggle('active', p.muteGroup1);
    this.ui.muteGroup2.classList.toggle('active', p.muteGroup2);
    this.ui.muteGroup3.classList.toggle('active', p.muteGroup3);
  }

  // Immediate play for manual pad tapping (keeps mute group behavior)
  async playNow(id){
    const p=this.pads[id]; if(!p||!p.buf) return;
    try{
      if(this.ctx.state==='suspended') await this.ctx.resume();

      // Enforce mute groups
      if(p.muteGroup1){
        Object.values(this.pads).forEach(pad => {
          if(pad.muteGroup1 && pad.id !== id && pad.currentSource){
            try{ pad.currentSource.stop(); }catch{}
            pad.currentSource.disconnect();
            pad.currentSource = null;
          }
        });
      }
      if(p.muteGroup2){
        Object.values(this.pads).forEach(pad => {
          if(pad.muteGroup2 && pad.id !== id && pad.currentSource){
            try{ pad.currentSource.stop(); }catch{}
            pad.currentSource.disconnect();
            pad.currentSource = null;
          }
        });
      }
      if(p.muteGroup3){
        Object.values(this.pads).forEach(pad => {
          if(pad.muteGroup3 && pad.id !== id && pad.currentSource){
            try{ pad.currentSource.stop(); }catch{}
            pad.currentSource.disconnect();
            pad.currentSource = null;
          }
        });
      }

      const s=this._buildSourceForPad(p);
      const dur=p.buf.duration, st=p.start*dur, en=p.end*dur;
      const stretchedDuration = (en - st) * p.timeStretch;
      s.start(0, st, Math.max(0.01, stretchedDuration));
      p.currentSource = s;
      s.onended = () => { if(p.currentSource === s) p.currentSource = null; };

      p.el.classList.add('active'); setTimeout(()=>p.el.classList.remove('active'), 120);
    }catch(err){ console.error('play failed', err); }
  }

  // Scheduled play (used by sequencer) - doesn't stop current sources
  playAt(id, whenAbs){
    const p=this.pads[id]; if(!p||!p.buf) return;
    const s=this._buildSourceForPad(p);
    const dur=p.buf.duration, st=p.start*dur, en=p.end*dur;
    const stretchedDuration = (en - st) * p.timeStretch;
    s.start(Math.max(0, whenAbs), st, Math.max(0.01, stretchedDuration));
  }

  _buildSourceForPad(p){
    const s=this.ctx.createBufferSource(); 
    s.buffer=p.buf; 
    const stretchedRate = p.pitch / p.timeStretch;
    s.playbackRate.value = stretchedRate;

    let filterNode = null;
    if(p.filter !== 50) {
      filterNode = this.ctx.createBiquadFilter();
      if(p.filter < 50) {
        filterNode.type = 'lowpass';
        filterNode.frequency.value = 20000 - (50 - p.filter) * 380;
      } else {
        filterNode.type = 'highpass';
        filterNode.frequency.value = 20 + (p.filter - 50) * 380;
      }
      filterNode.Q.value = 1;
    }

    const gainNode = this.ctx.createGain();
    gainNode.gain.value = p.vol;

    if(filterNode) { s.connect(filterNode); filterNode.connect(gainNode); }
    else { s.connect(gainNode); }
    gainNode.connect(this.masterIn);
    return s;
  }

  stopAllSounds(){
    Object.values(this.pads).forEach(pad => {
      if(pad.currentSource){
        try{ pad.currentSource.stop(); }catch{}
        pad.currentSource.disconnect();
        pad.currentSource = null;
      }
    });
  }

  async loadFile(e){
    const f=e.target.files[0]; if(!f||!this.sel) { e.target.value=''; return; }
    try{ 
      const ab=await f.arrayBuffer(); 
      const buf=await this.ctx.decodeAudioData(ab); 
      const p=this.pads[this.sel]; 
      p.buf=buf; p.name=f.name; 
      p.el.classList.add('has-sample'); 
      p.el.querySelector('.pad-name').textContent=p.name; 
      this.say('Loaded '+f.name+' → Pad '+this.sel); 
    }
    catch(err){ console.error(err); this.say('Load failed'); }
    e.target.value='';
  }

  clear(){
    if(!this.sel) return; const p=this.pads[this.sel];
    if(p.currentSource){ try{p.currentSource.stop();}catch{} p.currentSource.disconnect(); p.currentSource=null; }
    p.buf=null; p.name=`Pad ${p.id}`; p.vol=.85; p.pitch=1; p.start=0; p.end=1; 
    p.timeStretch=1; p.filter=50; p.muteGroup1=false; p.muteGroup2=false; p.muteGroup3=false;
    p.el.classList.remove('has-sample', 'muted1', 'muted2', 'muted3'); 
    p.el.querySelector('.pad-name').textContent=p.name; 
    this.select(this.sel); 
    this.say('Cleared Pad '+this.sel);
  }

  async toggleRec(){
    if(this.isRecording){ this.stopRec(); return; }
    if(this.sel && this.pads[this.sel].buf){
      // Respect user's preference: do not record over a filled pad
      this.say("Clear pad before recording");
      return;
    }
    const target = this.sel || this.findEmpty();
    if(!target){ this.say("No empty pads"); return; }

    try{
      const stream=await navigator.mediaDevices.getUserMedia({
        audio: { echoCancellation:false, noiseSuppression:false, autoGainControl:false, sampleRate:44100 }
      });
      this.recorder=new MediaRecorder(stream, {
        mimeType: MediaRecorder.isTypeSupported('audio/webm') ? 'audio/webm' : 'audio/mp4'
      }); 
      this.chunks=[];
      this.recorder.ondataavailable=e=>{ if(e.data.size>0) this.chunks.push(e.data); };
      this.recorder.onstop=async()=>{
        try{ 
          const blob=new Blob(this.chunks,{type: this.recorder.mimeType}); 
          const ab=await blob.arrayBuffer(); 
          const buf=await this.ctx.decodeAudioData(ab); 
          const p=this.pads[target]; 
          p.buf=buf; p.name='Recorded Sample'; 
          p.el.classList.add('has-sample'); 
          p.el.querySelector('.pad-name').textContent=p.name; 
          this.select(target); 
          this.say('Recorded → Pad '+target); 
        }catch(err){ console.error(err); this.say('Recording process failed'); }
        stream.getTracks().forEach(t=>t.stop());
        document.documentElement.classList.remove('rec-on');
      };
      this.recorder.start(); this.isRecording=true; this.say('Recording… tap Record again to stop');
      document.documentElement.classList.add('rec-on');
    }catch(err){ console.error('Mic error',err); this.say('Mic permission denied/unavailable'); }
  }
  stopRec(){ if(this.recorder&&this.isRecording){ this.recorder.stop(); this.isRecording=false; } }

  findEmpty(){ for(let i=1;i<=this.count;i++) if(!this.pads[i].buf) return i; return null; }
  say(m){ this.ui.status.textContent=m; }
}

/* Sequencer */
class Sequencer {
  constructor(sampler){
    this.sampler = sampler;
    this.ctx = sampler.ctx;

    this.isPlaying = false;
    this.currentStep = 0;            // 0..7
    this.tempo = 120;                // BPM
    this.swing = 50;                 // 50..100
    this.lookahead = 25;             // ms
    this.scheduleAheadTime = 0.12;   // seconds
    this.nextStepTime = 0;

    this.tapTimes = [];

    // 9 tracks x 8 steps pattern
    this.pattern = {};
    for(let t=1;t<=9;t++) this.pattern[t] = new Array(8).fill(false);

    this.ui = {
      playPause: document.getElementById('playPauseBtn'),
      tap: document.getElementById('tapTempoBtn'),
      tempo: document.getElementById('tempoInput'),
      swing: document.getElementById('swingSlider'),
      swingVal: document.getElementById('swingValue'),
      tracks: document.getElementById('sequencerTracks'),
      status: document.getElementById('status')
    };

    this.createTracks();
    this.bind();
  }

  createTracks(){
    for(let track=1; track<=9; track++){
      const row = document.createElement('div');
      row.className = 'track-row';
      const label = document.createElement('div');
      label.className = 'track-label';
      label.textContent = `Pad ${track}`;
      row.appendChild(label);
      for(let step=0; step<8; step++){
        const btn = document.createElement('div');
        btn.className = 'step-button';
        btn.dataset.track = track;
        btn.dataset.step = step;
        row.appendChild(btn);
      }
      this.ui.tracks.appendChild(row);
    }
  }

  bind(){
    this.ui.playPause.addEventListener('click', ()=> this.toggle());
    this.ui.tap.addEventListener('click', ()=> this.tapTempo());

    this.ui.tempo.addEventListener('input', e=>{
      const v = Math.max(60, Math.min(200, parseInt(e.target.value||120,10)));
      this.tempo = v; this.ui.tempo.value = v;
      this.say(`Tempo: ${v} BPM`);
    });

    this.ui.swing.addEventListener('input', e=>{
      this.swing = parseInt(e.target.value,10);
      this.ui.swingVal.textContent = `${this.swing}%`;
    });

    this.ui.tracks.addEventListener('click', (e)=>{
      if(!e.target.classList.contains('step-button')) return;
      const t = parseInt(e.target.dataset.track,10);
      const s = parseInt(e.target.dataset.step,10);
      this.pattern[t][s] = !this.pattern[t][s];
      e.target.classList.toggle('active', this.pattern[t][s]);
      if(this.pattern[t][s]) { // instant feedback
        this.sampler.playAt(t, this.ctx.currentTime);
      }
    });
  }

  toggle(){
    if(this.isPlaying) this.pause();
    else this.play();
  }

  play(){
    if(this.ctx.state === 'suspended') this.ctx.resume();
    this.isPlaying = true;
    this.ui.playPause.textContent = 'Pause';
    this.ui.playPause.classList.add('playing');
    this.nextStepTime = this.ctx.currentTime;
    this.scheduler();
    this.say('Playing');
  }

  pause(){
    this.isPlaying = false;
    this.ui.playPause.textContent = 'Play';
    this.ui.playPause.classList.remove('playing');
    this.say('Paused');
  }

  // 8-step grid uses 8th notes. Swing shifts odd steps (2,4,6,8)
  getStepDuration() {
    return 60.0 / this.tempo / 2; // 8th notes
  }

  // Swing offset fraction: from 0 (50%) to 0.5 (100%) of step duration
  getSwingOffset(stepIndex) {
    if (this.swing <= 50) return 0;
    if ((stepIndex % 2) === 1) {
      const factor = (this.swing - 50) / 50; // 0..1
      return this.getStepDuration() * 0.5 * factor;
    }
    return 0;
  }

  scheduler(){
    while (this.isPlaying && this.nextStepTime < this.ctx.currentTime + this.scheduleAheadTime) {
      const step = this.currentStep;

      const stepTime = this.nextStepTime + this.getSwingOffset(step);
      this.scheduleStep(step, stepTime);

      // prepare next base step time (without swing)
      this.nextStepTime += this.getStepDuration();
      this.currentStep = (this.currentStep + 1) % 8;
    }

    if(this.isPlaying) {
      setTimeout(()=>this.scheduler(), this.lookahead);
    }
  }

  scheduleStep(step, time){
    // Visuals at the right time
    const ms = Math.max(0, (time - this.ctx.currentTime) * 1000);
    setTimeout(()=>{
      if(!this.isPlaying) return;
      this.updateVisuals(step);
    }, ms);

    // Trigger tracks marked ON at this step
    for(let t=1; t<=9; t++){
      if(this.pattern[t][step]) {
        this.sampler.playAt(t, time);
      }
    }
  }

  updateVisuals(step){
    // clear previous
    document.querySelectorAll('.step-button').forEach(b=>{
      b.classList.remove('current-beat','playing');
    });
    // current beat
    document.querySelectorAll(`.step-button[data-step="${step}"]`).forEach(b=>{
      b.classList.add('current-beat');
      if (b.classList.contains('active')) b.classList.add('playing');
    });
  }

  tapTempo(){
    const now = Date.now();
    this.tapTimes.push(now);
    if(this.tapTimes.length > 6) this.tapTimes.shift();

    if(this.tapTimes.length >= 2) {
      const intervals = [];
      for(let i=1;i<this.tapTimes.length;i++){
        intervals.push(this.tapTimes[i]-this.tapTimes[i-1]);
      }
      const avg = intervals.reduce((a,b)=>a+b,0)/intervals.length;
      const bpm = Math.round(60000/avg);
      if(bpm>=60 && bpm<=200){
        this.tempo = bpm;
        this.ui.tempo.value = bpm;
        this.say(`Tempo: ${bpm} BPM`);
      }
    }

    // clear taps after 2s inactivity
    clearTimeout(this._tapClearTO);
    this._tapClearTO = setTimeout(()=>{
      if(this.tapTimes.length) this.tapTimes = [];
    }, 2000);
  }

  say(msg){ this.ui.status.textContent = msg; }
}

document.addEventListener('DOMContentLoaded', ()=>{
  const sampler = new Sampler();
  const seq = new Sequencer(sampler);

  // Back button wiring already in sampler.bind()

  // Optional: expose sequencer for debugging
  window.sequencer = seq;
});
</script>
</body>
</html>