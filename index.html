<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"/>
<title>Pelan Sampler v1.3.2</title>

<!-- PWA Meta Tags -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Pelan Sampler">
<meta name="mobile-web-app-capable" content="yes">
<meta name="theme-color" content="#1f1f1f">

<!-- Icons for iOS -->
<link rel="apple-touch-icon" sizes="180x180" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgwIiBoZWlnaHQ9IjE4MCIgdmlld0JveD0iMCAwIDE4MCAxODAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxODAiIGhlaWdodD0iMTgwIiByeD0iNDAiIGZpbGw9IiMxZjFmMWYiLz4KPHN2ZyB4PSI0MCIgeT0iNDAiIHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTAwIDEwMCI+CjxyZWN0IHg9IjEwIiB5PSIxMCIgd2lkdGg9IjIwIiBoZWlnaHQ9IjIwIiByeD0iNCIgZmlsbD0iIzJlOWI2MCIvPgo8cmVjdCB4PSI0MCIgeT0iMTAiIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgcng9IjQiIGZpbGw9IiMyZTliNjAiLz4KPHJlY3QgeD0iNzAiIHk9IjEwIiB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHJ4PSI0IiBmaWxsPSIjMmU5YjYwIi8+CjxyZWN0IHg9IjEwIiB5PSI0MCIgd2lkdGg9IjIwIiBoZWlnaHQ9IjIwIiByeD0iNCIgZmlsbD0iIzJlOWI2MCIvPgo8cmVjdCB4PSI0MCIgeT0iNDAiIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgcng9IjQiIGZpbGw9IiNlNjdlMjIiLz4KPHJlY3QgeD0iNzAiIHk9IjQwIiB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHJ4PSI0IiBmaWxsPSIjMmU5YjYwIi8+CjxyZWN0IHg9IjEwIiB5PSI3MCIgd2lkdGg9IjIwIiBoZWlnaHQ9IjIwIiByeD0iNCIgZmlsbD0iIzJlOWI2MCIvPgo8cmVjdCB4PSI0MCIgeT0iNzAiIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgcng9IjQiIGZpbGw9IiMyZTliNjAiLz4KPHJlY3QgeD0iNzAiIHk9IjcwIiB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHJ4PSI0IiBmaWxsPSIjMmU5YjYwIi8+CjwvZz4KPC9zdmc+">
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiByeD0iOCIgZmlsbD0iIzFmMWYxZiIvPgo8cmVjdCB4PSIyIiB5PSIyIiB3aWR0aD0iOCIgaGVpZ2h0PSI4IiByeD0iMiIgZmlsbD0iIzJlOWI2MCIvPgo8cmVjdCB4PSIxMiIgeT0iMiIgd2lkdGg9IjgiIGhlaWdodD0iOCIgcng9IjIiIGZpbGw9IiMyZTliNjAiLz4KPHJlY3QgeD0iMjIiIHk9IjIiIHdpZHRoPSI4IiBoZWlnaHQ9IjgiIHJ4PSIyIiBmaWxsPSIjMmU5YjYwIi8+CjxyZWN0IHg9IjIiIHk9IjEyIiB3aWR0aD0iOCIgaGVpZ2h0PSI4IiByeD0iMiIgZmlsbD0iIzJlOWI2MCIvPgo8cmVjdCB4PSIxMiIgeT0iMTIiIHdpZHRoPSI4IiBoZWlnaHQ9IjgiIHJ4PSIyIiBmaWxsPSIjZTY3ZTIyIi8+CjxyZWN0IHg9IjIyIiB5PSIxMiIgd2lkdGg9IjgiIGhlaWdodD0iOCIgcng9IjIiIGZpbGw9IiMyZTliNjAiLz4KPHJlY3QgeD0iMiIgeT0iMjIiIHdpZHRoPSI4IiBoZWlnaHQ9IjgiIHJ4PSIyIiBmaWxsPSIjMmU5YjYwIi8+CjxyZWN0IHg9IjEyIiB5PSIyMiIgd2lkdGg9IjgiIGhlaWdodD0iOCIgcng9IjIiIGZpbGw9IiMyZTliNjAiLz4KPHJlY3QgeD0iMjIiIHk9IjIyIiB3aWR0aD0iOCIgaGVpZ2h0PSI4IiByeD0iMiIgZmlsbD0iIzJlOWI2MCIvPgo8L3N2Zz4K">

<!-- PWA Manifest -->
<link rel="manifest" href="data:application/json;base64,ewogICJuYW1lIjogIlBlbGFuIFNhbXBsZXIiLAogICJzaG9ydF9uYW1lIjogIlBlbGFuIiwKICAiZGVzY3JpcHRpb24iOiAiQXVkaW8gU2FtcGxlciBmb3IgaU9TIiwKICAic3RhcnRfdXJsIjogIi8iLAogICJkaXNwbGF5IjogInN0YW5kYWxvbmUiLAogICJiYWNrZ3JvdW5kX2NvbG9yIjogIiMxZjFmMWYiLAogICJ0aGVtZV9jb2xvciI6ICIjMWYxZjFmIiwKICAiaWNvbnMiOiBbCiAgICB7CiAgICAgICJzcmMiOiAiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTVRnd0lpQm9aV2xuYUhROUlqRTRNQ0lpSUhacFpYZENiM2c5SWpBZ01DQXhPREFnTVRnd0lpQm1hV3hzUFNKdWIyNWxJaUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lQZ29nUEhKbFkzUWdkMmxrZEdnOUlqRTRNQ0lpSUdobGFXZG9kRDBpTVRnd0lpQnllRDBpTkRBaUlHWnBiR3c5SWlNeE1tWXhNbVlpTHo0S0lEeHpkbWNnZUQwaU5EQWlJSGs5SWpRd0lpQjNhV1IwYUQwaU1UQXdJaUJvWldsbmFIUTlJakV3TUNJS0lIWnBaWGRDYjNnOUlqQWdNQ0F4TURBZ01UQXdJajRLSUNBZ1BISmxZM1FnZUQwaU1UQWlJSGs5SWpFd0lpQjNhV1IwYUQwaU1qQWlJR2hsYVdkb2REMGlNakFpSUhKNFBTSTBJaUJtYVd4c1BTSWpNbVU1WWpZd0lpOCtDaUFnSUR4eVpXTjBJSGc5SWpRd0lpQjVQU0l4TUNJS0lIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lpSUhKNFBTSTBJaUJtYVd4c1BTSWpNbVU1WWpZd0lpOCtDaUFnSUR4eVpXTjBJSGc5SWpjd0lpQjVQU0l4TUNJS0lIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lpSUhKNFBTSTBJaUJtYVd4c1BTSWpNbVU1WWpZd0lpOCtDaUFnSUR4eVpXTjBJSGc5SWpFd0lpQjVQU0kwTUNJS0lIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lpSUhKNFBTSTBJaUJtYVd4c1BTSWpNbVU1WWpZd0lpOCtDaUFnSUR4eVpXTjBJSGc5SWpRd0lpQjVQU0kwTUNJS0lIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lpSUhKNFBTSTBJaUJtYVd4c1BTSWpaVFkzWlRJeUlpOCtDaUFnSUR4eVpXTjBJSGc5SWpjd0lpQjVQU0kwTUNJS0lIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lpSUhKNFBTSTBJaUJtYVd4c1BTSWpNbVU1WWpZd0lpOCtDaUFnSUR4eVpXTjBJSGc5SWpFd0lpQjVQU0kzTUNJS0lIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lpSUhKNFBTSTBJaUJtYVd4c1BTSWpNbVU1WWpZd0lpOCtDaUFnSUR4eVpXTjBJSGc5SWpRd0lpQjVQU0kzTUNJS0lIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lpSUhKNFBTSTBJaUJtYVd4c1BTSWpNbVU1WWpZd0lpOCtDaUFnSUR4eVpXTjBJSGc5SWpjd0lpQjVQU0kzTUNJS0lIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lpSUhKNFBTSTBJaUJtYVd4c1BTSWpNbVU1WWpZd0lpOCtDand2Wno0S1BDOXpkbWMrIiwKICAgICAgInNpemVzIjogIjE4MHgxODAiLAogICAgICAidHlwZSI6ICJpbWFnZS9zdmcreG1sIgogICAgfQogIF0KfQ==">

<style>
  * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
  html,body { 
    margin:0; 
    padding:10px; 
    background:#1f1f1f; 
    color:#fff; 
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif; 
    user-select:none; 
    -webkit-user-select:none; 
    touch-action: manipulation;
    /* iOS safe area support */
    padding-top: max(10px, env(safe-area-inset-top));
    padding-bottom: max(10px, env(safe-area-inset-bottom));
    padding-left: max(10px, env(safe-area-inset-left));
    padding-right: max(10px, env(safe-area-inset-right));
    /* Prevent iOS bounce */
    overscroll-behavior: none;
    -webkit-overflow-scrolling: touch;
    height: 100vh;
    height: 100dvh; /* Dynamic viewport height for iOS */
  }
  
  /* Prevent iOS zoom on input focus */
  input, select, textarea, button {
    font-size: 16px;
  }
  
  #versionLabel {
    text-align:center;
    margin-bottom:10px;
    font-size:13px;
    color:#aaa;
    font-weight:600;
  }
  
  .pad-grid { display:grid; grid-template-columns: repeat(3,1fr); gap:12px; margin-bottom:14px; }
  .pad {
    aspect-ratio:1; min-height:100px; background:#4d4d4d; border:2px solid #3b3b3b; border-radius:12px;
    display:flex; flex-direction:column; align-items:center; justify-content:center; cursor:pointer; 
    transition: transform .06s ease; position: relative;
    /* iOS touch improvements */
    -webkit-touch-callout: none;
    -webkit-user-select: none;
  }
  .pad:active { transform: scale(0.98); }
  .pad.active { background:#e67e22; }
  .pad.has-sample { background:#2e9b60; }
  .pad.selected { border-color:#f1c40f; }
  .pad.muted1::before { content:'M1'; position:absolute; top:4px; left:6px; font-size:9px; font-weight:bold; color:#ff6b6b; background:#333; border-radius:50%; width:18px; height:18px; display:flex; align-items:center; justify-content:center; }
  .pad.muted2::before { content:'M2'; position:absolute; top:4px; left:6px; font-size:9px; font-weight:bold; color:#00d1ff; background:#333; border-radius:50%; width:18px; height:18px; display:flex; align-items:center; justify-content:center; }
  .pad.muted3::before { content:'M3'; position:absolute; top:4px; left:28px; font-size:9px; font-weight:bold; color:#f1c40f; background:#333; border-radius:50%; width:18px; height:18px; display:flex; align-items:center; justify-content:center; }
  .pad-number { font-weight:800; font-size:18px; }
  .pad-name { font-size:12px; margin-top:4px; text-overflow:ellipsis; overflow:hidden; white-space:nowrap; max-width:90%; }

  button { 
    padding:10px 14px; border:none; border-radius:8px; font-weight:700; cursor:pointer; margin:4px; color:#fff; background:#444;
    /* iOS button improvements */
    -webkit-appearance: none;
    -webkit-touch-callout: none;
    font-size: 16px;
  }
  #recordBtn { background:#e74c3c; }
  #stopBtn { background:#3498db; }
  #stopBtn:disabled { opacity:.6; cursor:not-allowed; }
  #loadBtn { background:#27ae60; }
  .clear-btn { background:#c0392b; }
  #muteGroup1Btn { background:#9b59b6; }
  #muteGroup1Btn.active { background:#e74c3c; }
  #muteGroup2Btn { background:#3498db; }
  #muteGroup2Btn.active { background:#00d1ff; }
  #muteGroup3Btn { background:#f39c12; }
  #muteGroup3Btn.active { background:#f1c40f; color:#333; }

  #undoBtn { background:#7f8c8d; }
  #undoBtn:disabled { opacity:.6; cursor:not-allowed; }

  .controls { background:#2b2b2b; padding:10px; border-radius:10px; margin-top:8px; }
  .row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  .group { display:flex; align-items:center; gap:8px; flex:1 1 180px; }
  .group label { width:86px; font-size:13px; color:#ddd; }
  .group input[type=range] { 
    flex:1;
    /* iOS range slider improvements */
    -webkit-appearance: none;
    height: 6px;
    border-radius: 3px;
    background: #555;
    outline: none;
  }
  .group input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: #f1c40f;
    cursor: pointer;
  }
  .group span { width:48px; text-align:right; font-size:12px; opacity:.85; }

  #status { margin-top:8px; font-size:14px; opacity:.9; }

  /* Recording visuals */
  .rec-indicator { position: fixed; top: 0; left: 0; right: 0; height: 4px; background: linear-gradient(90deg, #ff0000, #ff5252); box-shadow: 0 0 12px #ff0000; opacity: 0; pointer-events: none; transition: opacity .2s; z-index: 9999; }
  .rec-on .rec-indicator { opacity: 1; animation: recPulse 1s infinite; }
  @keyframes recPulse { 0%{ box-shadow: 0 0 6px #ff0000; } 50%{ box-shadow: 0 0 16px #ff0000; } 100%{ box-shadow: 0 0 6px #ff0000; } }

  /* iOS specific improvements */
  @supports (-webkit-touch-callout: none) {
    .pad {
    -webkit-tap-highlight-color: rgba(0,0,0,0);
    }
    button {
    -webkit-tap-highlight-color: rgba(0,0,0,0);
    }
  }
</style>
</head>
<body>
  <div class="rec-indicator"></div>

  <div id="versionLabel">Pelan Sampler v1.3.2</div>

  <div class="pad-grid" id="padGrid"></div>

  <div>
    <button id="recordBtn">Record</button>
    <button id="stopBtn" disabled>Stop</button>
    <input type="file" id="fileInput" accept="audio/*" style="display:none;">
    <button id="loadBtn">Load</button>
    <button id="clearPad" class="clear-btn">Clear</button>
    <button id="muteGroup1Btn">Mute 1</button>
    <button id="undoBtn" disabled title="Undo (8 steps)">Undo</button>

    <button id="muteGroup2Btn">Mute 2</button>
    <button id="muteGroup3Btn">Mute 3</button>
  </div>

  <div class="controls">
    <div class="row">
    <div class="group">
    <label>Master Vol</label>
    <input type="range" id="masterVol" min="0" max="100" value="80">
    <span id="masterVolVal">80%</span>
    </div>
    <div class="group">
    <label>Pad Vol</label>
    <input type="range" id="padVol" min="0" max="100" value="80">
    <span id="padVolVal">80%</span>
    </div>
    </div>
    <div class="row">
    <div class="group">
    <label>Pitch</label>
    <input type="range" id="padPitch" min="0.5" max="2" step="0.1" value="1">
    <span id="padPitchVal">1.0x</span>
    </div>
    <div class="group">
    <label>Time Stretch</label>
    <input type="range" id="timeStretch" min="0.25" max="4" step="0.05" value="1">
    <span id="timeStretchVal">1.0x</span>
    </div>
    </div>
    <div class="row">
    <div class="group">
    <label>Start</label>
    <input type="range" id="padStart" min="0" max="100" value="0">
    <span id="padStartVal">0%</span>
    </div>
    <div class="group">
    <label>End</label>
    <input type="range" id="padEnd" min="0" max="100" value="100">
    <span id="padEndVal">100%</span>
    </div>
    </div>
    <div class="row">
    <div class="group">
    <label>Filter</label>
    <input type="range" id="filter" min="0" max="100" value="50">
    <span id="filterVal">OFF</span>
    </div>
    </div>
  </div>

  <div id="status">Ready</div>

<script>
// iOS compatibility improvements
(function(){
  // Prevent double-tap zoom
  let last=0; 
  document.addEventListener('touchend',e=>{
    const now=Date.now(); 
    if(now-last<300){
    e.preventDefault();
    } 
    last=now;
  },{passive:false,capture:true});
  
  // Prevent gesture zoom
  ['gesturestart','gesturechange','gestureend'].forEach(evt=>
    document.addEventListener(evt,e=>e.preventDefault())
  );
  
  // Prevent iOS bounce scroll
  document.addEventListener('touchmove', function(e) {
    if(e.target.closest('.controls')) return; // Allow scrolling in controls
    e.preventDefault();
  }, {passive: false});
})();

// Service Worker registration for PWA
if ('serviceWorker' in navigator) {
  window.addEventListener('load', function() {
    const swCode = `
    const CACHE_NAME = 'pelan-sampler-v1';
    self.addEventListener('install', event => {
    event.waitUntil(
    caches.open(CACHE_NAME).then(cache => {
    return cache.addAll(['/']);
    })
    );
    });
    self.addEventListener('fetch', event => {
    event.respondWith(
    caches.match(event.request).then(response => {
    return response || fetch(event.request);
    })
    );
    });
    `;
    
    const blob = new Blob([swCode], {type: 'application/javascript'});
    const swUrl = URL.createObjectURL(blob);
    
    navigator.serviceWorker.register(swUrl)
    .then(registration => console.log('SW registered'))
class UndoManager {
  constructor(capacity = 8, onApply = null) {
    this.stack = [];
    this.capacity = capacity;
    this.onApply = onApply;
  }
  get canUndo() { return this.stack.length > 0; }
  push(state) {
    this.stack.push(state);
    if (this.stack.length > this.capacity) this.stack.shift();
  }
  undo() {
    if (!this.canUndo) return null;
    const prev = this.stack.pop();
    if (this.onApply) this.onApply(prev);
    return prev;
  }
  clear() { this.stack = []; }
}


    .catch(error => console.log('SW registration failed'));
  });
}

class Sampler {
  constructor(){
    this.ctx = new (window.AudioContext||window.webkitAudioContext)({
    latencyHint:'interactive',
    sampleRate: 44100 // iOS compatibility
    });

    // Master chain
    this.masterIn = this.ctx.createGain();
    this.masterGain = this.ctx.createGain();
    this.masterIn.connect(this.masterGain);
    this.masterGain.connect(this.ctx.destination);
    undo: document.getElementById('undoBtn'),

    this.masterGain.gain.value = 0.8;

    // Pads
    this.pads = {}; this.sel = null; this.count = 9;

    // Recording
    this.recorder=null; this.chunks=[]; this.isRecording=false;

    // Stop button double-tap tracking
    // Undo manager (8 steps)
    this.undo = new UndoManager(8, (state)=> this.applyState(state));

    this.lastStopTap = 0;

    // UI
    this.ui = {
    grid: document.getElementById('padGrid'),
    file: document.getElementById('fileInput'), load: document.getElementById('loadBtn'), clear: document.getElementById('clearPad'),
    rec: document.getElementById('recordBtn'), stop: document.getElementById('stopBtn'), status: document.getElementById('status'),
    muteGroup1: document.getElementById('muteGroup1Btn'),
    muteGroup2: document.getElementById('muteGroup2Btn'),
    muteGroup3: document.getElementById('muteGroup3Btn'),
    mVol: document.getElementById('masterVol'), mVolVal: document.getElementById('masterVolVal'),
    vol: document.getElementById('padVol'), volVal: document.getElementById('padVolVal'),
    pitch: document.getElementById('padPitch'), pitchVal: document.getElementById('padPitchVal'),
    start: document.getElementById('padStart'), startVal: document.getElementById('padStartVal'),
    end: document.getElementById('padEnd'), endVal: document.getElementById('padEndVal'),
    timeStretch: document.getElementById('timeStretch'), timeStretchVal: document.getElementById('timeStretchVal'),
    filter: document.getElementById('filter'), filterVal: document.getElementById('filterVal')
    };

    this.makePads();
    this.bind();

    // iOS audio context unlock
    this.unlockAudioContext();
    
    // Ask for mic permission on start
    this.requestMicPermission();
  }

  // iOS requires user interaction to start audio context
  unlockAudioContext(){
    const unlock = () => {
    if(this.ctx.state === 'suspended') {
    this.ctx.resume().then(() => {
    document.removeEventListener('touchstart', unlock);
    document.removeEventListener('click', unlock);
    });
    }
    };
    document.addEventListener('touchstart', unlock);
    document.addEventListener('click', unlock);
  }

  async requestMicPermission(){
    try{
    const stream = await navigator.mediaDevices.getUserMedia({audio:true});
    stream.getTracks().forEach(t=>t.stop());
    this.say('Mic ready');
    }catch(err){
    console.warn('Mic permission not granted yet.');
    }
  }

  makePads(){
    for(let i=1;i<=this.count;i++){
    const d=document.createElement('div'); d.className='pad'; d.dataset.id=i;
    d.innerHTML=`<div class="pad-number">${i}</div><div class="pad-name">Pad ${i}</div>`;
    this.ui.grid.appendChild(d);
    this.pads[i]={ id:i, name:`Pad ${i}`, buf:null, vol:.85, pitch:1, start:0, end:1,
    // Undo button
    this.ui.undo.addEventListener('click', ()=>{
      const restored = this.undo.undo();
      this.ui.undo.disabled = !this.undo.canUndo;
      if(restored) this.say('Undid last action');
    });

    timeStretch: 1, filter: 50,
    muteGroup1: false, muteGroup2: false, muteGroup3: false, currentSource: null,
    el:d };
    }
  }

  bind(){
    // iOS-optimized touch events
    this.ui.grid.addEventListener('touchstart', (e)=>{
    e.preventDefault();
    const d=e.target.closest('.pad'); 
    if(!d) return; 
    const id=+d.dataset.id; 
    this.select(id); 
    this.play(id);
    }, {passive: false});

    // Fallback for non-touch devices
    this.ui.grid.addEventListener('click', (e)=>{
    const d=e.target.closest('.pad'); 
    if(!d) return; 
    const id=+d.dataset.id; 
    this.select(id); 
    this.play(id);
    });

    // File and basics
    this.ui.load.addEventListener('click', ()=>this.ui.file.click());
    this.ui.file.addEventListener('change', e=>{ this.undo.push(this.getState()); this.ui.undo.disabled = false; this.loadFile(e); });
    this.ui.clear.addEventListener('click', ()=>{ this.undo.push(this.getState()); this.ui.undo.disabled = false; this.clear(); });

    // Mute group toggles
    this.ui.muteGroup1.addEventListener('click', ()=>{
    if(!this.sel) return;
    const pad = this.pads[this.sel];
    // Note: Per user request, master volume changes are NOT undoable

    pad.muteGroup1 = !pad.muteGroup1;
    pad.el.classList.toggle('muted1', pad.muteGroup1);
    this.ui.muteGroup1.classList.toggle('active', pad.muteGroup1);
    this.say(`Pad ${this.sel} mute group 1 ${pad.muteGroup1 ? 'ON' : 'OFF'}`);
    });

    this.ui.muteGroup2.addEventListener('click', ()=>{
    if(!this.sel) return;
    const pad = this.pads[this.sel];
    pad.muteGroup2 = !pad.muteGroup2;
    pad.el.classList.toggle('muted2', pad.muteGroup2);
    this.ui.muteGroup2.classList.toggle('active', pad.muteGroup2);
    this.say(`Pad ${this.sel} mute group 2 ${pad.muteGroup2 ? 'ON' : 'OFF'}`);
    });

    this.ui.muteGroup3.addEventListener('click', ()=>{
    if(!this.sel) return;
    const pad = this.pads[this.sel];
    pad.muteGroup3 = !pad.muteGroup3;
    pad.el.classList.toggle('muted3', pad.muteGroup3);
    this.ui.muteGroup3.classList.toggle('active', pad.muteGroup3);
    this.say(`Pad ${this.sel} mute group 3 ${pad.muteGroup3 ? 'ON' : 'OFF'}`);
    });

    // Recording
    this.ui.rec.addEventListener('click', ()=>this.toggleRec());
    this.ui.stop.addEventListener('click', ()=>{
    const now = Date.now();
    if(now - this.lastStopTap < 500){ // Double tap within 500ms
    this.stopAllSounds();
    this.say('All sounds stopped');
    } else {
    this.stopRec();
    }
    this.lastStopTap = now;
    });

    // Global
    this.ui.mVol.addEventListener('input', e=>{ const v=e.target.value; this.masterGain.gain.value=v/100; this.ui.mVolVal.textContent=v+'%'; });

    // Pad params
    this.ui.vol.addEventListener('input', e=>{ if(!this.sel) return; const v=e.target.value/100; this.pads[this.sel].vol=v; this.ui.volVal.textContent=e.target.value+'%'; });
    this.ui.pitch.addEventListener('input', e=>{ if(!this.sel) return; const p=parseFloat(e.target.value); this.pads[this.sel].pitch=p; this.ui.pitchVal.textContent=p.toFixed(1)+'x'; });
    this.ui.start.addEventListener('input', e=>{ if(!this.sel) return; const s=e.target.value/100; this.pads[this.sel].start=s; this.ui.startVal.textContent=e.target.value+'%'; if(s>this.pads[this.sel].end){ this.pads[this.sel].end=s; this.ui.end.value=Math.round(s*100); this.ui.endVal.textContent=Math.round(s*100)+'%'; } });
    this.ui.end.addEventListener('input', e=>{ if(!this.sel) return; const en=e.target.value/100; this.pads[this.sel].end=en; this.ui.endVal.textContent=e.target.value+'%'; if(en<this.pads[this.sel].start){ this.pads[this.sel].start=en; this.ui.start.value=Math.round(en*100); this.ui.startVal.textContent=Math.round(en*100)+'%'; } });

    // Time stretch and filter
    this.ui.timeStretch.addEventListener('input', e=>{ 
    if(!this.sel) return; 
    const ts=parseFloat(e.target.value); 
    this.pads[this.sel].timeStretch=ts; 
    this.ui.timeStretchVal.textContent=ts.toFixed(2)+'x'; 
    });
    
    this.ui.filter.addEventListener('input', e=>{ 
    if(!this.sel) return; 
    const f=parseInt(e.target.value); 
    this.pads[this.sel].filter=f; 
    if(f === 50) {
    this.ui.filterVal.textContent='OFF';
    } else if(f < 50) {
    this.ui.filterVal.textContent='LP ' + Math.round((50-f)*2) + '%';
    } else {
    this.ui.filterVal.textContent='HP ' + Math.round((f-50)*2) + '%';
    }
    });
  }

  select(id){
    if(this.sel) this.pads[this.sel].el.classList.remove('selected');
    this.sel=id; this.pads[id].el.classList.add('selected');
    const p=this.pads[id];
    this.ui.vol.value=Math.round(p.vol*100); this.ui.volVal.textContent=Math.round(p.vol*100)+'%';
    this.ui.pitch.value=p.pitch; this.ui.pitchVal.textContent=p.pitch.toFixed(1)+'x';
    this.ui.start.value=Math.round(p.start*100); this.ui.startVal.textContent=Math.round(p.start*100)+'%';
    this.ui.end.value=Math.round(p.end*100); this.ui.endVal.textContent=Math.round(p.end*100)+'%';
    
    // Time stretch and filter
    this.ui.timeStretch.value=p.timeStretch; this.ui.timeStretchVal.textContent=p.timeStretch.toFixed(2)+'x';
    this.ui.filter.value=p.filter; 
    if(p.filter === 50) {
    this.ui.filterVal.textContent='OFF';
    } else if(p.filter < 50) {
    this.ui.filterVal.textContent='LP ' + Math.round((50-p.filter)*2) + '%';
    } else {
    this.ui.filterVal.textContent='HP ' + Math.round((p.filter-50)*2) + '%';
    }
    
    // Button states
    this.ui.muteGroup1.classList.toggle('active', p.muteGroup1);
    this.ui.muteGroup2.classList.toggle('active', p.muteGroup2);
    this.ui.muteGroup3.classList.toggle('active', p.muteGroup3);
  }

  async play(id){
    const p=this.pads[id]; if(!p||!p.buf) return;
    try{
    if(this.ctx.state==='suspended') await this.ctx.resume();
    
    // Stop any existing source on this pad first
    if(p.currentSource){
    try{ p.currentSource.stop(); }catch{}
    p.currentSource.disconnect();
    p.currentSource = null;
    }
    
    // Handle mute groups
    if(p.muteGroup1){
    Object.values(this.pads).forEach(pad => {
    if(pad.muteGroup1 && pad.id !== id && pad.currentSource){
    try{ pad.currentSource.stop(); }catch{}
    pad.currentSource.disconnect();
    pad.currentSource = null;
    }
    });
    }
    if(p.muteGroup2){
    Object.values(this.pads).forEach(pad => {
    if(pad.muteGroup2 && pad.id !== id && pad.currentSource){
    try{ pad.currentSource.stop(); }catch{}
    pad.currentSource.disconnect();
    pad.currentSource = null;
    }
    });
    }
    if(p.muteGroup3){
    Object.values(this.pads).forEach(pad => {
    if(pad.muteGroup3 && pad.id !== id && pad.currentSource){
    try{ pad.currentSource.stop(); }catch{}
    pad.currentSource.disconnect();
    pad.currentSource = null;
    }
    });
    }

    const s=this.ctx.createBufferSource(); 
    s.buffer=p.buf; 
    
    // Time stretch: adjust playback rate inversely to stretch time
    const stretchedRate = p.pitch / p.timeStretch;
    s.playbackRate.value = stretchedRate;

    // Create filter if needed
    let filterNode = null;
    if(p.filter !== 50) {
    filterNode = this.ctx.createBiquadFilter();
    if(p.filter < 50) {
    // Low pass filter
    filterNode.type = 'lowpass';
    filterNode.frequency.value = 20000 - (50 - p.filter) * 380; // 20kHz to 1kHz range
    } else {
    // High pass filter
    filterNode.type = 'highpass';
    filterNode.frequency.value = 20 + (p.filter - 50) * 380; // 20Hz to 19kHz range
  // Capture full sampler state (excluding master volume & transient audio nodes)
  getState(){
    return {
      pads: Object.fromEntries(Object.entries(this.pads).map(([id,p])=>[
        id,
        {
          id: p.id,
          name: p.name,
          hasBuf: !!p.buf,
          vol: p.vol,
          pitch: p.pitch,
          start: p.start,
          end: p.end,
          timeStretch: p.timeStretch,
          filter: p.filter,
          muteGroup1: p.muteGroup1,
          muteGroup2: p.muteGroup2,
          muteGroup3: p.muteGroup3
        }
      ])),
      sel: this.sel
    };
  }

  // Apply state back into the app
  applyState(state){
    if(!state) return;
    // Stop all current sounds before applying
    this.stopAllSounds();

    // Restore pad properties; note that we cannot restore AudioBuffer content if it was cleared and we didn't snapshot it.
    Object.entries(state.pads).forEach(([id, sp])=>{
      const p = this.pads[id];
      if(!p) return;
      p.name = sp.name;
      p.vol = sp.vol;
      p.pitch = sp.pitch;
      p.start = sp.start;
      p.end = sp.end;
      p.timeStretch = sp.timeStretch;
      p.filter = sp.filter;
      p.muteGroup1 = sp.muteGroup1;
      p.muteGroup2 = sp.muteGroup2;
      p.muteGroup3 = sp.muteGroup3;

      // Classes
      p.el.classList.toggle('has-sample', sp.hasBuf);
      p.el.classList.toggle('muted1', sp.muteGroup1);
      p.el.classList.toggle('muted2', sp.muteGroup2);
      p.el.classList.toggle('muted3', sp.muteGroup3);
      p.el.querySelector('.pad-name').textContent=p.name;
    });

    // Reselect
    if(state.sel) this.select(state.sel);
  }

    }
    filterNode.Q.value = 1;
    }

    // Build audio chain
    const gainNode = this.ctx.createGain();
    gainNode.gain.value = p.vol;

    if(filterNode) {
    s.connect(filterNode);
    filterNode.connect(gainNode);
    } else {
    s.connect(gainNode);
    }
    gainNode.connect(this.masterIn);

    const dur=p.buf.duration, st=p.start*dur, en=p.end*dur;
    
    // Adjust duration for time stretch
    const stretchedDuration = (en - st) * p.timeStretch;
    s.start(0, st, Math.max(0.01, stretchedDuration));
    
    p.currentSource = s;
    s.onended = () => { if(p.currentSource === s) p.currentSource = null; };
    
    p.el.classList.add('active'); setTimeout(()=>p.el.classList.remove('active'), 120);
    }catch(err){ console.error('play failed', err); }
  }

  stopAllSounds(){
    Object.values(this.pads).forEach(pad => {
    if(pad.currentSource){
    try{ pad.currentSource.stop(); }catch{}
    pad.currentSource.disconnect();
    pad.currentSource = null;
    }
    });
  }

  async loadFile(e){
    const f=e.target.files[0]; if(!f||!this.sel) { e.target.value=''; return; }
    try{ const ab=await f.arrayBuffer(); const buf=await this.ctx.decodeAudioData(ab); const p=this.pads[this.sel]; p.buf=buf; p.name=f.name; p.el.classList.add('has-sample'); p.el.querySelector('.pad-name').textContent=p.name; this.say('Loaded '+f.name+' → Pad '+this.sel); }
    catch(err){ console.error(err); this.say('Load failed'); }
    e.target.value='';
  }

  clear(){
    if(!this.sel) return; const p=this.pads[this.sel];
    
    // Stop current source if playing
    if(p.currentSource){ 
    try{p.currentSource.stop();}catch{} 
    p.currentSource.disconnect(); 
    p.currentSource=null; 
    }
    
    // Reset all pad properties
    p.buf=null; p.name=`Pad ${p.id}`; p.vol=.85; p.pitch=1; p.start=0; p.end=1; 
    p.timeStretch=1; p.filter=50; p.muteGroup1=false; p.muteGroup2=false; p.muteGroup3=false;
    
    // Update UI classes
    p.el.classList.remove('has-sample', 'muted1', 'muted2', 'muted3'); 
    p.el.querySelector('.pad-name').textContent=p.name; 
    
    // Refresh UI controls
    this.select(this.sel); 
    this.say('Cleared Pad '+this.sel);
  }

  async toggleRec(){
    if(this.isRecording){ this.stopRec(); return; }
    try{
    const stream=await navigator.mediaDevices.getUserMedia({
    audio: {
    echoCancellation: false,
    noiseSuppression: false,
    autoGainControl: false,
    sampleRate: 44100 // iOS compatibility
    }
    });
    this.recorder=new MediaRecorder(stream, {
    mimeType: MediaRecorder.isTypeSupported('audio/webm') ? 'audio/webm' : 'audio/mp4'
    }); 
    this.chunks=[];
    this.recorder.ondataavailable=e=>{ if(e.data.size>0) this.chunks.push(e.data); };
    this.recorder.onstop=async()=>{
    try{ 
    const blob=new Blob(this.chunks,{type: this.recorder.mimeType}); 
    const ab=await blob.arrayBuffer(); 
    const buf=await this.ctx.decodeAudioData(ab); 
    const target=this.sel||this.findEmpty();
    if(target){ 
    const p=this.pads[target]; 
    p.buf=buf; 
    p.name='Recorded Sample'; 
    p.el.classList.add('has-sample'); 
    p.el.querySelector('.pad-name').textContent=p.name; 
    this.select(target); 
    this.say('Recorded → Pad '+target); 
    } else { 
    this.say('No empty pads'); 
    }
    }catch(err){ 
    console.error(err); 
    this.say('Recording process failed'); 
    }
    stream.getTracks().forEach(t=>t.stop());
    document.documentElement.classList.remove('rec-on');
    };
    this.recorder.start(); this.isRecording=true; this.ui.stop.disabled=false; this.say('Recording… tap Stop');
    document.documentElement.classList.add('rec-on');
    }catch(err){ console.error('Mic error',err); this.say('Mic permission denied/unavailable'); }
  }
  stopRec(){ if(this.recorder&&this.isRecording){ this.recorder.stop(); this.isRecording=false; this.ui.stop.disabled=true; } }

  findEmpty(){ for(let i=1;i<=this.count;i++) if(!this.pads[i].buf) return i; return null; }
  say(m){ this.ui.status.textContent=m; }
}

document.addEventListener('DOMContentLoaded', ()=> new Sampler());
</script>
</body>
</html>